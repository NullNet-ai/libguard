// This file is @generated by prost-build.
/// Standard timestamp representation
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Timestamp {
    /// Seconds since epoch
    #[prost(int64, tag = "1")]
    pub seconds: i64,
    /// Nanoseconds offset
    #[prost(int32, tag = "2")]
    pub nanos: i32,
}
/// Common parameter structure for Create requests
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateParams {
    /// Table name
    #[prost(string, tag = "1")]
    pub table: ::prost::alloc::string::String,
}
/// Common query structure for Create requests
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateQuery {
    /// Field to pluck (e.g., "id")
    #[prost(string, tag = "1")]
    pub pluck: ::prost::alloc::string::String,
    /// Durability level (e.g., "soft")
    #[prost(string, tag = "2")]
    pub durability: ::prost::alloc::string::String,
}
/// Items entity definition
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Items {
    #[prost(int32, tag = "1")]
    pub tombstone: i32,
    #[prost(string, tag = "2")]
    pub status: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "3")]
    pub previous_status: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, tag = "4")]
    pub version: i32,
    #[prost(string, optional, tag = "5")]
    pub created_date: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "6")]
    pub created_time: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "7")]
    pub updated_date: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "8")]
    pub updated_time: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "9")]
    pub organization_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "10")]
    pub created_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "11")]
    pub updated_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "12")]
    pub deleted_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "13")]
    pub requested_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "14")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(int32, tag = "15")]
    pub id: i32,
    #[prost(string, tag = "16")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "17")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
}
/// Packets entity definition
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Packets {
    #[prost(int32, optional, tag = "1")]
    pub tombstone: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "2")]
    pub status: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3")]
    pub previous_status: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "4")]
    pub version: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "5")]
    pub created_date: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "6")]
    pub created_time: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "7")]
    pub updated_date: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "8")]
    pub updated_time: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "9")]
    pub organization_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "10")]
    pub created_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "11")]
    pub updated_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "12")]
    pub deleted_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "13")]
    pub requested_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "14")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "15")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "16")]
    pub timestamp: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "17")]
    pub hypertable_timestamp: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "18")]
    pub interface_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19")]
    pub device_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "20")]
    pub source_mac: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "21")]
    pub destination_mac: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "22")]
    pub ether_type: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "23")]
    pub protocol: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "24")]
    pub total_length: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "25")]
    pub source_ip: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "26")]
    pub destination_ip: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "27")]
    pub source_port: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "28")]
    pub destination_port: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "29")]
    pub tcp_header_length: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "30")]
    pub tcp_sequence_number: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "31")]
    pub tcp_acknowledgment_number: ::core::option::Option<i64>,
    #[prost(int32, optional, tag = "32")]
    pub tcp_data_offset: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "33")]
    pub tcp_flags: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "34")]
    pub tcp_window_size: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "35")]
    pub tcp_urgent_pointer: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "36")]
    pub icmp_type: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "37")]
    pub icmp_code: ::core::option::Option<i32>,
}
/// Connections entity definition
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Connections {
    #[prost(int32, optional, tag = "1")]
    pub tombstone: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "2")]
    pub status: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3")]
    pub previous_status: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "4")]
    pub version: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "5")]
    pub created_date: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "6")]
    pub created_time: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "7")]
    pub updated_date: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "8")]
    pub updated_time: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "9")]
    pub organization_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "10")]
    pub created_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "11")]
    pub updated_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "12")]
    pub deleted_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "13")]
    pub requested_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "14")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "15")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "16")]
    pub timestamp: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "17")]
    pub interface_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "18")]
    pub hypertable_timestamp: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "19")]
    pub total_packet: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "20")]
    pub total_bytes: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "21")]
    pub device_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "22")]
    pub protocol: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "23")]
    pub source_ip: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "24")]
    pub destination_ip: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "25")]
    pub remote_ip: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "26")]
    pub source_port: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "27")]
    pub destination_port: ::core::option::Option<i32>,
}
/// CrdtMessages entity definition
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CrdtMessages {
    #[prost(string, optional, tag = "1")]
    pub database: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "2")]
    pub dataset: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub group_id: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub timestamp: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub row: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub column: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub client_id: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub value: ::prost::alloc::string::String,
    #[prost(string, tag = "9")]
    pub operation: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "10")]
    pub hypertable_timestamp: ::core::option::Option<::prost::alloc::string::String>,
}
/// CrdtMerkles entity definition
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CrdtMerkles {
    #[prost(string, tag = "1")]
    pub group_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub timestamp: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub merkle: ::prost::alloc::string::String,
}
/// SyncEndpoints entity definition
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SyncEndpoints {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub url: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub group_id: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub username: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub password: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub status: ::prost::alloc::string::String,
}
/// Queues entity definition
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Queues {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub size: i32,
    #[prost(int32, tag = "4")]
    pub count: i32,
}
/// QueueItems entity definition
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueueItems {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub order: i32,
    #[prost(string, tag = "3")]
    pub queue_id: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub value: ::prost::alloc::string::String,
}
/// Transactions entity definition
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Transactions {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub timestamp: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub status: ::prost::alloc::string::String,
    #[prost(int64, tag = "4")]
    pub expiry: i64,
}
/// Create Items request
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateItemsRequest {
    #[prost(message, optional, tag = "1")]
    pub items: ::core::option::Option<Items>,
    #[prost(message, optional, tag = "2")]
    pub params: ::core::option::Option<CreateParams>,
    #[prost(message, optional, tag = "3")]
    pub query: ::core::option::Option<CreateQuery>,
    /// Entity prefix code
    #[prost(string, tag = "4")]
    pub entity_prefix: ::prost::alloc::string::String,
}
/// Create Items response
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateItemsResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(int32, tag = "2")]
    pub count: i32,
    #[prost(string, tag = "3")]
    pub message: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub data: ::core::option::Option<Items>,
}
/// Get Items request
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetItemsRequest {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
/// Get Items response
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetItemsResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub data: ::core::option::Option<Items>,
}
/// Update Items request
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateItemsRequest {
    #[prost(message, optional, tag = "1")]
    pub items: ::core::option::Option<Items>,
}
/// Update Items response
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateItemsResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub data: ::core::option::Option<Items>,
}
/// Delete Items request
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteItemsRequest {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
/// Delete Items response
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteItemsResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
}
/// Create Packets request
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreatePacketsRequest {
    #[prost(message, optional, tag = "1")]
    pub packets: ::core::option::Option<Packets>,
    #[prost(message, optional, tag = "2")]
    pub params: ::core::option::Option<CreateParams>,
    #[prost(message, optional, tag = "3")]
    pub query: ::core::option::Option<CreateQuery>,
    /// Entity prefix code
    #[prost(string, tag = "4")]
    pub entity_prefix: ::prost::alloc::string::String,
}
/// Create Packets response
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreatePacketsResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(int32, tag = "2")]
    pub count: i32,
    #[prost(string, tag = "3")]
    pub message: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub data: ::core::option::Option<Packets>,
}
/// Get Packets request
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPacketsRequest {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
/// Get Packets response
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPacketsResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub data: ::core::option::Option<Packets>,
}
/// Update Packets request
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdatePacketsRequest {
    #[prost(message, optional, tag = "1")]
    pub packets: ::core::option::Option<Packets>,
}
/// Update Packets response
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdatePacketsResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub data: ::core::option::Option<Packets>,
}
/// Delete Packets request
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeletePacketsRequest {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
/// Delete Packets response
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeletePacketsResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
}
/// Create Connections request
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateConnectionsRequest {
    #[prost(message, optional, tag = "1")]
    pub connections: ::core::option::Option<Connections>,
    #[prost(message, optional, tag = "2")]
    pub params: ::core::option::Option<CreateParams>,
    #[prost(message, optional, tag = "3")]
    pub query: ::core::option::Option<CreateQuery>,
    /// Entity prefix code
    #[prost(string, tag = "4")]
    pub entity_prefix: ::prost::alloc::string::String,
}
/// Create Connections response
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateConnectionsResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(int32, tag = "2")]
    pub count: i32,
    #[prost(string, tag = "3")]
    pub message: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub data: ::core::option::Option<Connections>,
}
/// Get Connections request
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetConnectionsRequest {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
/// Get Connections response
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetConnectionsResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub data: ::core::option::Option<Connections>,
}
/// Update Connections request
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateConnectionsRequest {
    #[prost(message, optional, tag = "1")]
    pub connections: ::core::option::Option<Connections>,
}
/// Update Connections response
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateConnectionsResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub data: ::core::option::Option<Connections>,
}
/// Delete Connections request
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteConnectionsRequest {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
/// Delete Connections response
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteConnectionsResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
}
/// Create CrdtMessages request
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateCrdtMessagesRequest {
    #[prost(message, optional, tag = "1")]
    pub crdt_messages: ::core::option::Option<CrdtMessages>,
    #[prost(message, optional, tag = "2")]
    pub params: ::core::option::Option<CreateParams>,
    #[prost(message, optional, tag = "3")]
    pub query: ::core::option::Option<CreateQuery>,
    /// Entity prefix code
    #[prost(string, tag = "4")]
    pub entity_prefix: ::prost::alloc::string::String,
}
/// Create CrdtMessages response
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateCrdtMessagesResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(int32, tag = "2")]
    pub count: i32,
    #[prost(string, tag = "3")]
    pub message: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub data: ::core::option::Option<CrdtMessages>,
}
/// Get CrdtMessages request
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCrdtMessagesRequest {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
/// Get CrdtMessages response
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCrdtMessagesResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub data: ::core::option::Option<CrdtMessages>,
}
/// Update CrdtMessages request
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateCrdtMessagesRequest {
    #[prost(message, optional, tag = "1")]
    pub crdt_messages: ::core::option::Option<CrdtMessages>,
}
/// Update CrdtMessages response
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateCrdtMessagesResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub data: ::core::option::Option<CrdtMessages>,
}
/// Delete CrdtMessages request
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteCrdtMessagesRequest {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
/// Delete CrdtMessages response
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteCrdtMessagesResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
}
/// Create CrdtMerkles request
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateCrdtMerklesRequest {
    #[prost(message, optional, tag = "1")]
    pub crdt_merkles: ::core::option::Option<CrdtMerkles>,
    #[prost(message, optional, tag = "2")]
    pub params: ::core::option::Option<CreateParams>,
    #[prost(message, optional, tag = "3")]
    pub query: ::core::option::Option<CreateQuery>,
    /// Entity prefix code
    #[prost(string, tag = "4")]
    pub entity_prefix: ::prost::alloc::string::String,
}
/// Create CrdtMerkles response
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateCrdtMerklesResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(int32, tag = "2")]
    pub count: i32,
    #[prost(string, tag = "3")]
    pub message: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub data: ::core::option::Option<CrdtMerkles>,
}
/// Get CrdtMerkles request
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCrdtMerklesRequest {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
/// Get CrdtMerkles response
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCrdtMerklesResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub data: ::core::option::Option<CrdtMerkles>,
}
/// Update CrdtMerkles request
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateCrdtMerklesRequest {
    #[prost(message, optional, tag = "1")]
    pub crdt_merkles: ::core::option::Option<CrdtMerkles>,
}
/// Update CrdtMerkles response
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateCrdtMerklesResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub data: ::core::option::Option<CrdtMerkles>,
}
/// Delete CrdtMerkles request
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteCrdtMerklesRequest {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
/// Delete CrdtMerkles response
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteCrdtMerklesResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
}
/// Create SyncEndpoints request
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateSyncEndpointsRequest {
    #[prost(message, optional, tag = "1")]
    pub sync_endpoints: ::core::option::Option<SyncEndpoints>,
    #[prost(message, optional, tag = "2")]
    pub params: ::core::option::Option<CreateParams>,
    #[prost(message, optional, tag = "3")]
    pub query: ::core::option::Option<CreateQuery>,
    /// Entity prefix code
    #[prost(string, tag = "4")]
    pub entity_prefix: ::prost::alloc::string::String,
}
/// Create SyncEndpoints response
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateSyncEndpointsResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(int32, tag = "2")]
    pub count: i32,
    #[prost(string, tag = "3")]
    pub message: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub data: ::core::option::Option<SyncEndpoints>,
}
/// Get SyncEndpoints request
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSyncEndpointsRequest {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
/// Get SyncEndpoints response
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSyncEndpointsResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub data: ::core::option::Option<SyncEndpoints>,
}
/// Update SyncEndpoints request
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateSyncEndpointsRequest {
    #[prost(message, optional, tag = "1")]
    pub sync_endpoints: ::core::option::Option<SyncEndpoints>,
}
/// Update SyncEndpoints response
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateSyncEndpointsResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub data: ::core::option::Option<SyncEndpoints>,
}
/// Delete SyncEndpoints request
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteSyncEndpointsRequest {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
/// Delete SyncEndpoints response
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteSyncEndpointsResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
}
/// Create Queues request
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateQueuesRequest {
    #[prost(message, optional, tag = "1")]
    pub queues: ::core::option::Option<Queues>,
    #[prost(message, optional, tag = "2")]
    pub params: ::core::option::Option<CreateParams>,
    #[prost(message, optional, tag = "3")]
    pub query: ::core::option::Option<CreateQuery>,
    /// Entity prefix code
    #[prost(string, tag = "4")]
    pub entity_prefix: ::prost::alloc::string::String,
}
/// Create Queues response
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateQueuesResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(int32, tag = "2")]
    pub count: i32,
    #[prost(string, tag = "3")]
    pub message: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub data: ::core::option::Option<Queues>,
}
/// Get Queues request
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetQueuesRequest {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
/// Get Queues response
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetQueuesResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub data: ::core::option::Option<Queues>,
}
/// Update Queues request
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateQueuesRequest {
    #[prost(message, optional, tag = "1")]
    pub queues: ::core::option::Option<Queues>,
}
/// Update Queues response
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateQueuesResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub data: ::core::option::Option<Queues>,
}
/// Delete Queues request
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteQueuesRequest {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
/// Delete Queues response
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteQueuesResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
}
/// Create QueueItems request
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateQueueItemsRequest {
    #[prost(message, optional, tag = "1")]
    pub queue_items: ::core::option::Option<QueueItems>,
    #[prost(message, optional, tag = "2")]
    pub params: ::core::option::Option<CreateParams>,
    #[prost(message, optional, tag = "3")]
    pub query: ::core::option::Option<CreateQuery>,
    /// Entity prefix code
    #[prost(string, tag = "4")]
    pub entity_prefix: ::prost::alloc::string::String,
}
/// Create QueueItems response
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateQueueItemsResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(int32, tag = "2")]
    pub count: i32,
    #[prost(string, tag = "3")]
    pub message: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub data: ::core::option::Option<QueueItems>,
}
/// Get QueueItems request
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetQueueItemsRequest {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
/// Get QueueItems response
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetQueueItemsResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub data: ::core::option::Option<QueueItems>,
}
/// Update QueueItems request
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateQueueItemsRequest {
    #[prost(message, optional, tag = "1")]
    pub queue_items: ::core::option::Option<QueueItems>,
}
/// Update QueueItems response
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateQueueItemsResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub data: ::core::option::Option<QueueItems>,
}
/// Delete QueueItems request
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteQueueItemsRequest {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
/// Delete QueueItems response
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteQueueItemsResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
}
/// Create Transactions request
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateTransactionsRequest {
    #[prost(message, optional, tag = "1")]
    pub transactions: ::core::option::Option<Transactions>,
    #[prost(message, optional, tag = "2")]
    pub params: ::core::option::Option<CreateParams>,
    #[prost(message, optional, tag = "3")]
    pub query: ::core::option::Option<CreateQuery>,
    /// Entity prefix code
    #[prost(string, tag = "4")]
    pub entity_prefix: ::prost::alloc::string::String,
}
/// Create Transactions response
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateTransactionsResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(int32, tag = "2")]
    pub count: i32,
    #[prost(string, tag = "3")]
    pub message: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub data: ::core::option::Option<Transactions>,
}
/// Get Transactions request
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTransactionsRequest {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
/// Get Transactions response
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTransactionsResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub data: ::core::option::Option<Transactions>,
}
/// Update Transactions request
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateTransactionsRequest {
    #[prost(message, optional, tag = "1")]
    pub transactions: ::core::option::Option<Transactions>,
}
/// Update Transactions response
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateTransactionsResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub data: ::core::option::Option<Transactions>,
}
/// Delete Transactions request
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteTransactionsRequest {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
/// Delete Transactions response
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteTransactionsResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod store_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Store service definition with CRUD operations
    #[derive(Debug, Clone)]
    pub struct StoreServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl StoreServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> StoreServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> StoreServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            StoreServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Create a new Items
        pub async fn create_items(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateItemsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreateItemsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/store.StoreService/CreateItems",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("store.StoreService", "CreateItems"));
            self.inner.unary(req, path, codec).await
        }
        /// Get a Items by ID
        pub async fn get_items(
            &mut self,
            request: impl tonic::IntoRequest<super::GetItemsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetItemsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/store.StoreService/GetItems",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("store.StoreService", "GetItems"));
            self.inner.unary(req, path, codec).await
        }
        /// Update an existing Items
        pub async fn update_items(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateItemsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateItemsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/store.StoreService/UpdateItems",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("store.StoreService", "UpdateItems"));
            self.inner.unary(req, path, codec).await
        }
        /// Delete a Items by ID
        pub async fn delete_items(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteItemsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeleteItemsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/store.StoreService/DeleteItems",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("store.StoreService", "DeleteItems"));
            self.inner.unary(req, path, codec).await
        }
        /// Create a new Packets
        pub async fn create_packets(
            &mut self,
            request: impl tonic::IntoRequest<super::CreatePacketsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreatePacketsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/store.StoreService/CreatePackets",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("store.StoreService", "CreatePackets"));
            self.inner.unary(req, path, codec).await
        }
        /// Get a Packets by ID
        pub async fn get_packets(
            &mut self,
            request: impl tonic::IntoRequest<super::GetPacketsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetPacketsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/store.StoreService/GetPackets",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("store.StoreService", "GetPackets"));
            self.inner.unary(req, path, codec).await
        }
        /// Update an existing Packets
        pub async fn update_packets(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdatePacketsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdatePacketsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/store.StoreService/UpdatePackets",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("store.StoreService", "UpdatePackets"));
            self.inner.unary(req, path, codec).await
        }
        /// Delete a Packets by ID
        pub async fn delete_packets(
            &mut self,
            request: impl tonic::IntoRequest<super::DeletePacketsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeletePacketsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/store.StoreService/DeletePackets",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("store.StoreService", "DeletePackets"));
            self.inner.unary(req, path, codec).await
        }
        /// Create a new Connections
        pub async fn create_connections(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateConnectionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreateConnectionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/store.StoreService/CreateConnections",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("store.StoreService", "CreateConnections"));
            self.inner.unary(req, path, codec).await
        }
        /// Get a Connections by ID
        pub async fn get_connections(
            &mut self,
            request: impl tonic::IntoRequest<super::GetConnectionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetConnectionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/store.StoreService/GetConnections",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("store.StoreService", "GetConnections"));
            self.inner.unary(req, path, codec).await
        }
        /// Update an existing Connections
        pub async fn update_connections(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateConnectionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateConnectionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/store.StoreService/UpdateConnections",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("store.StoreService", "UpdateConnections"));
            self.inner.unary(req, path, codec).await
        }
        /// Delete a Connections by ID
        pub async fn delete_connections(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteConnectionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeleteConnectionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/store.StoreService/DeleteConnections",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("store.StoreService", "DeleteConnections"));
            self.inner.unary(req, path, codec).await
        }
        /// Create a new CrdtMessages
        pub async fn create_crdt_messages(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateCrdtMessagesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreateCrdtMessagesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/store.StoreService/CreateCrdtMessages",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("store.StoreService", "CreateCrdtMessages"));
            self.inner.unary(req, path, codec).await
        }
        /// Get a CrdtMessages by ID
        pub async fn get_crdt_messages(
            &mut self,
            request: impl tonic::IntoRequest<super::GetCrdtMessagesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetCrdtMessagesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/store.StoreService/GetCrdtMessages",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("store.StoreService", "GetCrdtMessages"));
            self.inner.unary(req, path, codec).await
        }
        /// Update an existing CrdtMessages
        pub async fn update_crdt_messages(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateCrdtMessagesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateCrdtMessagesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/store.StoreService/UpdateCrdtMessages",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("store.StoreService", "UpdateCrdtMessages"));
            self.inner.unary(req, path, codec).await
        }
        /// Delete a CrdtMessages by ID
        pub async fn delete_crdt_messages(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteCrdtMessagesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeleteCrdtMessagesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/store.StoreService/DeleteCrdtMessages",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("store.StoreService", "DeleteCrdtMessages"));
            self.inner.unary(req, path, codec).await
        }
        /// Create a new CrdtMerkles
        pub async fn create_crdt_merkles(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateCrdtMerklesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreateCrdtMerklesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/store.StoreService/CreateCrdtMerkles",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("store.StoreService", "CreateCrdtMerkles"));
            self.inner.unary(req, path, codec).await
        }
        /// Get a CrdtMerkles by ID
        pub async fn get_crdt_merkles(
            &mut self,
            request: impl tonic::IntoRequest<super::GetCrdtMerklesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetCrdtMerklesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/store.StoreService/GetCrdtMerkles",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("store.StoreService", "GetCrdtMerkles"));
            self.inner.unary(req, path, codec).await
        }
        /// Update an existing CrdtMerkles
        pub async fn update_crdt_merkles(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateCrdtMerklesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateCrdtMerklesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/store.StoreService/UpdateCrdtMerkles",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("store.StoreService", "UpdateCrdtMerkles"));
            self.inner.unary(req, path, codec).await
        }
        /// Delete a CrdtMerkles by ID
        pub async fn delete_crdt_merkles(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteCrdtMerklesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeleteCrdtMerklesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/store.StoreService/DeleteCrdtMerkles",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("store.StoreService", "DeleteCrdtMerkles"));
            self.inner.unary(req, path, codec).await
        }
        /// Create a new SyncEndpoints
        pub async fn create_sync_endpoints(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateSyncEndpointsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreateSyncEndpointsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/store.StoreService/CreateSyncEndpoints",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("store.StoreService", "CreateSyncEndpoints"));
            self.inner.unary(req, path, codec).await
        }
        /// Get a SyncEndpoints by ID
        pub async fn get_sync_endpoints(
            &mut self,
            request: impl tonic::IntoRequest<super::GetSyncEndpointsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetSyncEndpointsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/store.StoreService/GetSyncEndpoints",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("store.StoreService", "GetSyncEndpoints"));
            self.inner.unary(req, path, codec).await
        }
        /// Update an existing SyncEndpoints
        pub async fn update_sync_endpoints(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateSyncEndpointsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateSyncEndpointsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/store.StoreService/UpdateSyncEndpoints",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("store.StoreService", "UpdateSyncEndpoints"));
            self.inner.unary(req, path, codec).await
        }
        /// Delete a SyncEndpoints by ID
        pub async fn delete_sync_endpoints(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteSyncEndpointsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeleteSyncEndpointsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/store.StoreService/DeleteSyncEndpoints",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("store.StoreService", "DeleteSyncEndpoints"));
            self.inner.unary(req, path, codec).await
        }
        /// Create a new Queues
        pub async fn create_queues(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateQueuesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreateQueuesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/store.StoreService/CreateQueues",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("store.StoreService", "CreateQueues"));
            self.inner.unary(req, path, codec).await
        }
        /// Get a Queues by ID
        pub async fn get_queues(
            &mut self,
            request: impl tonic::IntoRequest<super::GetQueuesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetQueuesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/store.StoreService/GetQueues",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("store.StoreService", "GetQueues"));
            self.inner.unary(req, path, codec).await
        }
        /// Update an existing Queues
        pub async fn update_queues(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateQueuesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateQueuesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/store.StoreService/UpdateQueues",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("store.StoreService", "UpdateQueues"));
            self.inner.unary(req, path, codec).await
        }
        /// Delete a Queues by ID
        pub async fn delete_queues(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteQueuesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeleteQueuesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/store.StoreService/DeleteQueues",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("store.StoreService", "DeleteQueues"));
            self.inner.unary(req, path, codec).await
        }
        /// Create a new QueueItems
        pub async fn create_queue_items(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateQueueItemsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreateQueueItemsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/store.StoreService/CreateQueueItems",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("store.StoreService", "CreateQueueItems"));
            self.inner.unary(req, path, codec).await
        }
        /// Get a QueueItems by ID
        pub async fn get_queue_items(
            &mut self,
            request: impl tonic::IntoRequest<super::GetQueueItemsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetQueueItemsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/store.StoreService/GetQueueItems",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("store.StoreService", "GetQueueItems"));
            self.inner.unary(req, path, codec).await
        }
        /// Update an existing QueueItems
        pub async fn update_queue_items(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateQueueItemsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateQueueItemsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/store.StoreService/UpdateQueueItems",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("store.StoreService", "UpdateQueueItems"));
            self.inner.unary(req, path, codec).await
        }
        /// Delete a QueueItems by ID
        pub async fn delete_queue_items(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteQueueItemsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeleteQueueItemsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/store.StoreService/DeleteQueueItems",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("store.StoreService", "DeleteQueueItems"));
            self.inner.unary(req, path, codec).await
        }
        /// Create a new Transactions
        pub async fn create_transactions(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateTransactionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreateTransactionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/store.StoreService/CreateTransactions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("store.StoreService", "CreateTransactions"));
            self.inner.unary(req, path, codec).await
        }
        /// Get a Transactions by ID
        pub async fn get_transactions(
            &mut self,
            request: impl tonic::IntoRequest<super::GetTransactionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetTransactionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/store.StoreService/GetTransactions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("store.StoreService", "GetTransactions"));
            self.inner.unary(req, path, codec).await
        }
        /// Update an existing Transactions
        pub async fn update_transactions(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateTransactionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateTransactionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/store.StoreService/UpdateTransactions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("store.StoreService", "UpdateTransactions"));
            self.inner.unary(req, path, codec).await
        }
        /// Delete a Transactions by ID
        pub async fn delete_transactions(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteTransactionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeleteTransactionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/store.StoreService/DeleteTransactions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("store.StoreService", "DeleteTransactions"));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod store_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with StoreServiceServer.
    #[async_trait]
    pub trait StoreService: std::marker::Send + std::marker::Sync + 'static {
        /// Create a new Items
        async fn create_items(
            &self,
            request: tonic::Request<super::CreateItemsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreateItemsResponse>,
            tonic::Status,
        >;
        /// Get a Items by ID
        async fn get_items(
            &self,
            request: tonic::Request<super::GetItemsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetItemsResponse>,
            tonic::Status,
        >;
        /// Update an existing Items
        async fn update_items(
            &self,
            request: tonic::Request<super::UpdateItemsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateItemsResponse>,
            tonic::Status,
        >;
        /// Delete a Items by ID
        async fn delete_items(
            &self,
            request: tonic::Request<super::DeleteItemsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeleteItemsResponse>,
            tonic::Status,
        >;
        /// Create a new Packets
        async fn create_packets(
            &self,
            request: tonic::Request<super::CreatePacketsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreatePacketsResponse>,
            tonic::Status,
        >;
        /// Get a Packets by ID
        async fn get_packets(
            &self,
            request: tonic::Request<super::GetPacketsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetPacketsResponse>,
            tonic::Status,
        >;
        /// Update an existing Packets
        async fn update_packets(
            &self,
            request: tonic::Request<super::UpdatePacketsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdatePacketsResponse>,
            tonic::Status,
        >;
        /// Delete a Packets by ID
        async fn delete_packets(
            &self,
            request: tonic::Request<super::DeletePacketsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeletePacketsResponse>,
            tonic::Status,
        >;
        /// Create a new Connections
        async fn create_connections(
            &self,
            request: tonic::Request<super::CreateConnectionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreateConnectionsResponse>,
            tonic::Status,
        >;
        /// Get a Connections by ID
        async fn get_connections(
            &self,
            request: tonic::Request<super::GetConnectionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetConnectionsResponse>,
            tonic::Status,
        >;
        /// Update an existing Connections
        async fn update_connections(
            &self,
            request: tonic::Request<super::UpdateConnectionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateConnectionsResponse>,
            tonic::Status,
        >;
        /// Delete a Connections by ID
        async fn delete_connections(
            &self,
            request: tonic::Request<super::DeleteConnectionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeleteConnectionsResponse>,
            tonic::Status,
        >;
        /// Create a new CrdtMessages
        async fn create_crdt_messages(
            &self,
            request: tonic::Request<super::CreateCrdtMessagesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreateCrdtMessagesResponse>,
            tonic::Status,
        >;
        /// Get a CrdtMessages by ID
        async fn get_crdt_messages(
            &self,
            request: tonic::Request<super::GetCrdtMessagesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetCrdtMessagesResponse>,
            tonic::Status,
        >;
        /// Update an existing CrdtMessages
        async fn update_crdt_messages(
            &self,
            request: tonic::Request<super::UpdateCrdtMessagesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateCrdtMessagesResponse>,
            tonic::Status,
        >;
        /// Delete a CrdtMessages by ID
        async fn delete_crdt_messages(
            &self,
            request: tonic::Request<super::DeleteCrdtMessagesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeleteCrdtMessagesResponse>,
            tonic::Status,
        >;
        /// Create a new CrdtMerkles
        async fn create_crdt_merkles(
            &self,
            request: tonic::Request<super::CreateCrdtMerklesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreateCrdtMerklesResponse>,
            tonic::Status,
        >;
        /// Get a CrdtMerkles by ID
        async fn get_crdt_merkles(
            &self,
            request: tonic::Request<super::GetCrdtMerklesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetCrdtMerklesResponse>,
            tonic::Status,
        >;
        /// Update an existing CrdtMerkles
        async fn update_crdt_merkles(
            &self,
            request: tonic::Request<super::UpdateCrdtMerklesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateCrdtMerklesResponse>,
            tonic::Status,
        >;
        /// Delete a CrdtMerkles by ID
        async fn delete_crdt_merkles(
            &self,
            request: tonic::Request<super::DeleteCrdtMerklesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeleteCrdtMerklesResponse>,
            tonic::Status,
        >;
        /// Create a new SyncEndpoints
        async fn create_sync_endpoints(
            &self,
            request: tonic::Request<super::CreateSyncEndpointsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreateSyncEndpointsResponse>,
            tonic::Status,
        >;
        /// Get a SyncEndpoints by ID
        async fn get_sync_endpoints(
            &self,
            request: tonic::Request<super::GetSyncEndpointsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetSyncEndpointsResponse>,
            tonic::Status,
        >;
        /// Update an existing SyncEndpoints
        async fn update_sync_endpoints(
            &self,
            request: tonic::Request<super::UpdateSyncEndpointsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateSyncEndpointsResponse>,
            tonic::Status,
        >;
        /// Delete a SyncEndpoints by ID
        async fn delete_sync_endpoints(
            &self,
            request: tonic::Request<super::DeleteSyncEndpointsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeleteSyncEndpointsResponse>,
            tonic::Status,
        >;
        /// Create a new Queues
        async fn create_queues(
            &self,
            request: tonic::Request<super::CreateQueuesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreateQueuesResponse>,
            tonic::Status,
        >;
        /// Get a Queues by ID
        async fn get_queues(
            &self,
            request: tonic::Request<super::GetQueuesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetQueuesResponse>,
            tonic::Status,
        >;
        /// Update an existing Queues
        async fn update_queues(
            &self,
            request: tonic::Request<super::UpdateQueuesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateQueuesResponse>,
            tonic::Status,
        >;
        /// Delete a Queues by ID
        async fn delete_queues(
            &self,
            request: tonic::Request<super::DeleteQueuesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeleteQueuesResponse>,
            tonic::Status,
        >;
        /// Create a new QueueItems
        async fn create_queue_items(
            &self,
            request: tonic::Request<super::CreateQueueItemsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreateQueueItemsResponse>,
            tonic::Status,
        >;
        /// Get a QueueItems by ID
        async fn get_queue_items(
            &self,
            request: tonic::Request<super::GetQueueItemsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetQueueItemsResponse>,
            tonic::Status,
        >;
        /// Update an existing QueueItems
        async fn update_queue_items(
            &self,
            request: tonic::Request<super::UpdateQueueItemsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateQueueItemsResponse>,
            tonic::Status,
        >;
        /// Delete a QueueItems by ID
        async fn delete_queue_items(
            &self,
            request: tonic::Request<super::DeleteQueueItemsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeleteQueueItemsResponse>,
            tonic::Status,
        >;
        /// Create a new Transactions
        async fn create_transactions(
            &self,
            request: tonic::Request<super::CreateTransactionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreateTransactionsResponse>,
            tonic::Status,
        >;
        /// Get a Transactions by ID
        async fn get_transactions(
            &self,
            request: tonic::Request<super::GetTransactionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetTransactionsResponse>,
            tonic::Status,
        >;
        /// Update an existing Transactions
        async fn update_transactions(
            &self,
            request: tonic::Request<super::UpdateTransactionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateTransactionsResponse>,
            tonic::Status,
        >;
        /// Delete a Transactions by ID
        async fn delete_transactions(
            &self,
            request: tonic::Request<super::DeleteTransactionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeleteTransactionsResponse>,
            tonic::Status,
        >;
    }
    /// Store service definition with CRUD operations
    #[derive(Debug)]
    pub struct StoreServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> StoreServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for StoreServiceServer<T>
    where
        T: StoreService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/store.StoreService/CreateItems" => {
                    #[allow(non_camel_case_types)]
                    struct CreateItemsSvc<T: StoreService>(pub Arc<T>);
                    impl<
                        T: StoreService,
                    > tonic::server::UnaryService<super::CreateItemsRequest>
                    for CreateItemsSvc<T> {
                        type Response = super::CreateItemsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CreateItemsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as StoreService>::create_items(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CreateItemsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/store.StoreService/GetItems" => {
                    #[allow(non_camel_case_types)]
                    struct GetItemsSvc<T: StoreService>(pub Arc<T>);
                    impl<
                        T: StoreService,
                    > tonic::server::UnaryService<super::GetItemsRequest>
                    for GetItemsSvc<T> {
                        type Response = super::GetItemsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetItemsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as StoreService>::get_items(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetItemsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/store.StoreService/UpdateItems" => {
                    #[allow(non_camel_case_types)]
                    struct UpdateItemsSvc<T: StoreService>(pub Arc<T>);
                    impl<
                        T: StoreService,
                    > tonic::server::UnaryService<super::UpdateItemsRequest>
                    for UpdateItemsSvc<T> {
                        type Response = super::UpdateItemsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UpdateItemsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as StoreService>::update_items(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UpdateItemsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/store.StoreService/DeleteItems" => {
                    #[allow(non_camel_case_types)]
                    struct DeleteItemsSvc<T: StoreService>(pub Arc<T>);
                    impl<
                        T: StoreService,
                    > tonic::server::UnaryService<super::DeleteItemsRequest>
                    for DeleteItemsSvc<T> {
                        type Response = super::DeleteItemsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeleteItemsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as StoreService>::delete_items(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DeleteItemsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/store.StoreService/CreatePackets" => {
                    #[allow(non_camel_case_types)]
                    struct CreatePacketsSvc<T: StoreService>(pub Arc<T>);
                    impl<
                        T: StoreService,
                    > tonic::server::UnaryService<super::CreatePacketsRequest>
                    for CreatePacketsSvc<T> {
                        type Response = super::CreatePacketsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CreatePacketsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as StoreService>::create_packets(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CreatePacketsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/store.StoreService/GetPackets" => {
                    #[allow(non_camel_case_types)]
                    struct GetPacketsSvc<T: StoreService>(pub Arc<T>);
                    impl<
                        T: StoreService,
                    > tonic::server::UnaryService<super::GetPacketsRequest>
                    for GetPacketsSvc<T> {
                        type Response = super::GetPacketsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetPacketsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as StoreService>::get_packets(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetPacketsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/store.StoreService/UpdatePackets" => {
                    #[allow(non_camel_case_types)]
                    struct UpdatePacketsSvc<T: StoreService>(pub Arc<T>);
                    impl<
                        T: StoreService,
                    > tonic::server::UnaryService<super::UpdatePacketsRequest>
                    for UpdatePacketsSvc<T> {
                        type Response = super::UpdatePacketsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UpdatePacketsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as StoreService>::update_packets(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UpdatePacketsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/store.StoreService/DeletePackets" => {
                    #[allow(non_camel_case_types)]
                    struct DeletePacketsSvc<T: StoreService>(pub Arc<T>);
                    impl<
                        T: StoreService,
                    > tonic::server::UnaryService<super::DeletePacketsRequest>
                    for DeletePacketsSvc<T> {
                        type Response = super::DeletePacketsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeletePacketsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as StoreService>::delete_packets(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DeletePacketsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/store.StoreService/CreateConnections" => {
                    #[allow(non_camel_case_types)]
                    struct CreateConnectionsSvc<T: StoreService>(pub Arc<T>);
                    impl<
                        T: StoreService,
                    > tonic::server::UnaryService<super::CreateConnectionsRequest>
                    for CreateConnectionsSvc<T> {
                        type Response = super::CreateConnectionsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CreateConnectionsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as StoreService>::create_connections(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CreateConnectionsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/store.StoreService/GetConnections" => {
                    #[allow(non_camel_case_types)]
                    struct GetConnectionsSvc<T: StoreService>(pub Arc<T>);
                    impl<
                        T: StoreService,
                    > tonic::server::UnaryService<super::GetConnectionsRequest>
                    for GetConnectionsSvc<T> {
                        type Response = super::GetConnectionsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetConnectionsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as StoreService>::get_connections(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetConnectionsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/store.StoreService/UpdateConnections" => {
                    #[allow(non_camel_case_types)]
                    struct UpdateConnectionsSvc<T: StoreService>(pub Arc<T>);
                    impl<
                        T: StoreService,
                    > tonic::server::UnaryService<super::UpdateConnectionsRequest>
                    for UpdateConnectionsSvc<T> {
                        type Response = super::UpdateConnectionsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UpdateConnectionsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as StoreService>::update_connections(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UpdateConnectionsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/store.StoreService/DeleteConnections" => {
                    #[allow(non_camel_case_types)]
                    struct DeleteConnectionsSvc<T: StoreService>(pub Arc<T>);
                    impl<
                        T: StoreService,
                    > tonic::server::UnaryService<super::DeleteConnectionsRequest>
                    for DeleteConnectionsSvc<T> {
                        type Response = super::DeleteConnectionsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeleteConnectionsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as StoreService>::delete_connections(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DeleteConnectionsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/store.StoreService/CreateCrdtMessages" => {
                    #[allow(non_camel_case_types)]
                    struct CreateCrdtMessagesSvc<T: StoreService>(pub Arc<T>);
                    impl<
                        T: StoreService,
                    > tonic::server::UnaryService<super::CreateCrdtMessagesRequest>
                    for CreateCrdtMessagesSvc<T> {
                        type Response = super::CreateCrdtMessagesResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CreateCrdtMessagesRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as StoreService>::create_crdt_messages(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CreateCrdtMessagesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/store.StoreService/GetCrdtMessages" => {
                    #[allow(non_camel_case_types)]
                    struct GetCrdtMessagesSvc<T: StoreService>(pub Arc<T>);
                    impl<
                        T: StoreService,
                    > tonic::server::UnaryService<super::GetCrdtMessagesRequest>
                    for GetCrdtMessagesSvc<T> {
                        type Response = super::GetCrdtMessagesResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetCrdtMessagesRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as StoreService>::get_crdt_messages(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetCrdtMessagesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/store.StoreService/UpdateCrdtMessages" => {
                    #[allow(non_camel_case_types)]
                    struct UpdateCrdtMessagesSvc<T: StoreService>(pub Arc<T>);
                    impl<
                        T: StoreService,
                    > tonic::server::UnaryService<super::UpdateCrdtMessagesRequest>
                    for UpdateCrdtMessagesSvc<T> {
                        type Response = super::UpdateCrdtMessagesResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UpdateCrdtMessagesRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as StoreService>::update_crdt_messages(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UpdateCrdtMessagesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/store.StoreService/DeleteCrdtMessages" => {
                    #[allow(non_camel_case_types)]
                    struct DeleteCrdtMessagesSvc<T: StoreService>(pub Arc<T>);
                    impl<
                        T: StoreService,
                    > tonic::server::UnaryService<super::DeleteCrdtMessagesRequest>
                    for DeleteCrdtMessagesSvc<T> {
                        type Response = super::DeleteCrdtMessagesResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeleteCrdtMessagesRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as StoreService>::delete_crdt_messages(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DeleteCrdtMessagesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/store.StoreService/CreateCrdtMerkles" => {
                    #[allow(non_camel_case_types)]
                    struct CreateCrdtMerklesSvc<T: StoreService>(pub Arc<T>);
                    impl<
                        T: StoreService,
                    > tonic::server::UnaryService<super::CreateCrdtMerklesRequest>
                    for CreateCrdtMerklesSvc<T> {
                        type Response = super::CreateCrdtMerklesResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CreateCrdtMerklesRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as StoreService>::create_crdt_merkles(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CreateCrdtMerklesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/store.StoreService/GetCrdtMerkles" => {
                    #[allow(non_camel_case_types)]
                    struct GetCrdtMerklesSvc<T: StoreService>(pub Arc<T>);
                    impl<
                        T: StoreService,
                    > tonic::server::UnaryService<super::GetCrdtMerklesRequest>
                    for GetCrdtMerklesSvc<T> {
                        type Response = super::GetCrdtMerklesResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetCrdtMerklesRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as StoreService>::get_crdt_merkles(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetCrdtMerklesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/store.StoreService/UpdateCrdtMerkles" => {
                    #[allow(non_camel_case_types)]
                    struct UpdateCrdtMerklesSvc<T: StoreService>(pub Arc<T>);
                    impl<
                        T: StoreService,
                    > tonic::server::UnaryService<super::UpdateCrdtMerklesRequest>
                    for UpdateCrdtMerklesSvc<T> {
                        type Response = super::UpdateCrdtMerklesResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UpdateCrdtMerklesRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as StoreService>::update_crdt_merkles(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UpdateCrdtMerklesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/store.StoreService/DeleteCrdtMerkles" => {
                    #[allow(non_camel_case_types)]
                    struct DeleteCrdtMerklesSvc<T: StoreService>(pub Arc<T>);
                    impl<
                        T: StoreService,
                    > tonic::server::UnaryService<super::DeleteCrdtMerklesRequest>
                    for DeleteCrdtMerklesSvc<T> {
                        type Response = super::DeleteCrdtMerklesResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeleteCrdtMerklesRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as StoreService>::delete_crdt_merkles(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DeleteCrdtMerklesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/store.StoreService/CreateSyncEndpoints" => {
                    #[allow(non_camel_case_types)]
                    struct CreateSyncEndpointsSvc<T: StoreService>(pub Arc<T>);
                    impl<
                        T: StoreService,
                    > tonic::server::UnaryService<super::CreateSyncEndpointsRequest>
                    for CreateSyncEndpointsSvc<T> {
                        type Response = super::CreateSyncEndpointsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CreateSyncEndpointsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as StoreService>::create_sync_endpoints(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CreateSyncEndpointsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/store.StoreService/GetSyncEndpoints" => {
                    #[allow(non_camel_case_types)]
                    struct GetSyncEndpointsSvc<T: StoreService>(pub Arc<T>);
                    impl<
                        T: StoreService,
                    > tonic::server::UnaryService<super::GetSyncEndpointsRequest>
                    for GetSyncEndpointsSvc<T> {
                        type Response = super::GetSyncEndpointsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetSyncEndpointsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as StoreService>::get_sync_endpoints(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetSyncEndpointsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/store.StoreService/UpdateSyncEndpoints" => {
                    #[allow(non_camel_case_types)]
                    struct UpdateSyncEndpointsSvc<T: StoreService>(pub Arc<T>);
                    impl<
                        T: StoreService,
                    > tonic::server::UnaryService<super::UpdateSyncEndpointsRequest>
                    for UpdateSyncEndpointsSvc<T> {
                        type Response = super::UpdateSyncEndpointsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UpdateSyncEndpointsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as StoreService>::update_sync_endpoints(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UpdateSyncEndpointsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/store.StoreService/DeleteSyncEndpoints" => {
                    #[allow(non_camel_case_types)]
                    struct DeleteSyncEndpointsSvc<T: StoreService>(pub Arc<T>);
                    impl<
                        T: StoreService,
                    > tonic::server::UnaryService<super::DeleteSyncEndpointsRequest>
                    for DeleteSyncEndpointsSvc<T> {
                        type Response = super::DeleteSyncEndpointsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeleteSyncEndpointsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as StoreService>::delete_sync_endpoints(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DeleteSyncEndpointsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/store.StoreService/CreateQueues" => {
                    #[allow(non_camel_case_types)]
                    struct CreateQueuesSvc<T: StoreService>(pub Arc<T>);
                    impl<
                        T: StoreService,
                    > tonic::server::UnaryService<super::CreateQueuesRequest>
                    for CreateQueuesSvc<T> {
                        type Response = super::CreateQueuesResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CreateQueuesRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as StoreService>::create_queues(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CreateQueuesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/store.StoreService/GetQueues" => {
                    #[allow(non_camel_case_types)]
                    struct GetQueuesSvc<T: StoreService>(pub Arc<T>);
                    impl<
                        T: StoreService,
                    > tonic::server::UnaryService<super::GetQueuesRequest>
                    for GetQueuesSvc<T> {
                        type Response = super::GetQueuesResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetQueuesRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as StoreService>::get_queues(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetQueuesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/store.StoreService/UpdateQueues" => {
                    #[allow(non_camel_case_types)]
                    struct UpdateQueuesSvc<T: StoreService>(pub Arc<T>);
                    impl<
                        T: StoreService,
                    > tonic::server::UnaryService<super::UpdateQueuesRequest>
                    for UpdateQueuesSvc<T> {
                        type Response = super::UpdateQueuesResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UpdateQueuesRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as StoreService>::update_queues(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UpdateQueuesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/store.StoreService/DeleteQueues" => {
                    #[allow(non_camel_case_types)]
                    struct DeleteQueuesSvc<T: StoreService>(pub Arc<T>);
                    impl<
                        T: StoreService,
                    > tonic::server::UnaryService<super::DeleteQueuesRequest>
                    for DeleteQueuesSvc<T> {
                        type Response = super::DeleteQueuesResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeleteQueuesRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as StoreService>::delete_queues(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DeleteQueuesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/store.StoreService/CreateQueueItems" => {
                    #[allow(non_camel_case_types)]
                    struct CreateQueueItemsSvc<T: StoreService>(pub Arc<T>);
                    impl<
                        T: StoreService,
                    > tonic::server::UnaryService<super::CreateQueueItemsRequest>
                    for CreateQueueItemsSvc<T> {
                        type Response = super::CreateQueueItemsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CreateQueueItemsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as StoreService>::create_queue_items(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CreateQueueItemsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/store.StoreService/GetQueueItems" => {
                    #[allow(non_camel_case_types)]
                    struct GetQueueItemsSvc<T: StoreService>(pub Arc<T>);
                    impl<
                        T: StoreService,
                    > tonic::server::UnaryService<super::GetQueueItemsRequest>
                    for GetQueueItemsSvc<T> {
                        type Response = super::GetQueueItemsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetQueueItemsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as StoreService>::get_queue_items(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetQueueItemsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/store.StoreService/UpdateQueueItems" => {
                    #[allow(non_camel_case_types)]
                    struct UpdateQueueItemsSvc<T: StoreService>(pub Arc<T>);
                    impl<
                        T: StoreService,
                    > tonic::server::UnaryService<super::UpdateQueueItemsRequest>
                    for UpdateQueueItemsSvc<T> {
                        type Response = super::UpdateQueueItemsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UpdateQueueItemsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as StoreService>::update_queue_items(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UpdateQueueItemsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/store.StoreService/DeleteQueueItems" => {
                    #[allow(non_camel_case_types)]
                    struct DeleteQueueItemsSvc<T: StoreService>(pub Arc<T>);
                    impl<
                        T: StoreService,
                    > tonic::server::UnaryService<super::DeleteQueueItemsRequest>
                    for DeleteQueueItemsSvc<T> {
                        type Response = super::DeleteQueueItemsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeleteQueueItemsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as StoreService>::delete_queue_items(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DeleteQueueItemsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/store.StoreService/CreateTransactions" => {
                    #[allow(non_camel_case_types)]
                    struct CreateTransactionsSvc<T: StoreService>(pub Arc<T>);
                    impl<
                        T: StoreService,
                    > tonic::server::UnaryService<super::CreateTransactionsRequest>
                    for CreateTransactionsSvc<T> {
                        type Response = super::CreateTransactionsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CreateTransactionsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as StoreService>::create_transactions(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CreateTransactionsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/store.StoreService/GetTransactions" => {
                    #[allow(non_camel_case_types)]
                    struct GetTransactionsSvc<T: StoreService>(pub Arc<T>);
                    impl<
                        T: StoreService,
                    > tonic::server::UnaryService<super::GetTransactionsRequest>
                    for GetTransactionsSvc<T> {
                        type Response = super::GetTransactionsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetTransactionsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as StoreService>::get_transactions(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetTransactionsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/store.StoreService/UpdateTransactions" => {
                    #[allow(non_camel_case_types)]
                    struct UpdateTransactionsSvc<T: StoreService>(pub Arc<T>);
                    impl<
                        T: StoreService,
                    > tonic::server::UnaryService<super::UpdateTransactionsRequest>
                    for UpdateTransactionsSvc<T> {
                        type Response = super::UpdateTransactionsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UpdateTransactionsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as StoreService>::update_transactions(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UpdateTransactionsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/store.StoreService/DeleteTransactions" => {
                    #[allow(non_camel_case_types)]
                    struct DeleteTransactionsSvc<T: StoreService>(pub Arc<T>);
                    impl<
                        T: StoreService,
                    > tonic::server::UnaryService<super::DeleteTransactionsRequest>
                    for DeleteTransactionsSvc<T> {
                        type Response = super::DeleteTransactionsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeleteTransactionsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as StoreService>::delete_transactions(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DeleteTransactionsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for StoreServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "store.StoreService";
    impl<T> tonic::server::NamedService for StoreServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
